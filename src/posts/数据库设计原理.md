---
title: "数据库设计原理"
excerpt: "深入学习数据库设计原理，掌握关系型数据库设计和优化技术。"
author: "CodeBuddy"
category: "数据库"
tags: ["数据库设计", "SQL", "数据建模", "性能优化"]
publishedAt: "2024-04-12"
updatedAt: "2024-04-12"
readTime: 33
coverImage: "https://images.unsplash.com/photo-1544383835-bda2bc66a55d?w=800&h=400&fit=crop"
isPublished: true
---

# 数据库设计原理

数据库设计是构建高效、可维护数据系统的基础。本文将深入探讨关系型数据库的设计原理、范式理论、索引优化等核心概念。

## 数据库设计基础

### 实体关系模型

```sql
-- 用户管理系统数据库设计示例

-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    date_of_birth DATE,
    gender ENUM('M', 'F', 'Other'),
    status ENUM('Active', 'Inactive', 'Suspended') DEFAULT 'Active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);

-- 用户角色表
CREATE TABLE roles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    permissions JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 用户角色关联表（多对多关系）
CREATE TABLE user_roles (
    user_id BIGINT,
    role_id INT,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT,
    
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (assigned_by) REFERENCES users(id) ON DELETE SET NULL,
    
    INDEX idx_user_id (user_id),
    INDEX idx_role_id (role_id),
    INDEX idx_assigned_at (assigned_at)
);

-- 用户配置表（一对一关系）
CREATE TABLE user_preferences (
    user_id BIGINT PRIMARY KEY,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    theme ENUM('light', 'dark', 'auto') DEFAULT 'light',
    notifications JSON,
    privacy_settings JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 用户会话表
CREATE TABLE user_sessions (
    id VARCHAR(128) PRIMARY KEY,
    user_id BIGINT NOT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT,
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    
    INDEX idx_user_id (user_id),
    INDEX idx_expires_at (expires_at),
    INDEX idx_last_activity (last_activity)
);

-- 审计日志表
CREATE TABLE audit_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50),
    resource_id VARCHAR(100),
    old_values JSON,
    new_values JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL,
    
    INDEX idx_user_id (user_id),
    INDEX idx_action (action),
    INDEX idx_resource (resource_type, resource_id),
    INDEX idx_created_at (created_at)
);
```

### 数据库范式

```sql
-- 第一范式（1NF）- 原子性
-- 错误示例：非原子性数据
CREATE TABLE users_bad (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    phones VARCHAR(200), -- 存储多个电话号码，违反1NF
    address VARCHAR(500) -- 包含多个地址组件，违反1NF
);

-- 正确示例：符合1NF
CREATE TABLE users_1nf (
    id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    primary_phone VARCHAR(20),
    street_address VARCHAR(200),
    city VARCHAR(50),
    state VARCHAR(50),
    postal_code VARCHAR(20),
    country VARCHAR(50)
);

-- 第二范式（2NF）- 消除部分依赖
-- 错误示例：存在部分依赖
CREATE TABLE order_items_bad (
    order_id INT,
    product_id INT,
    product_name VARCHAR(100), -- 依赖于product_id，不依赖于完整主键
    product_price DECIMAL(10,2), -- 依赖于product_id，不依赖于完整主键
    quantity INT,
    
    PRIMARY KEY (order_id, product_id)
);

-- 正确示例：符合2NF
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    description TEXT
);

CREATE TABLE order_items_2nf (
    order_id INT,
    product_id INT,
    quantity INT,
    unit_price DECIMAL(10,2), -- 订单时的价格，可能与当前产品价格不同
    
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);

-- 第三范式（3NF）- 消除传递依赖
-- 错误示例：存在传递依赖
CREATE TABLE employees_bad (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department_id INT,
    department_name VARCHAR(100), -- 传递依赖：依赖于department_id
    department_location VARCHAR(100) -- 传递依赖：依赖于department_id
);

-- 正确示例：符合3NF
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    location VARCHAR(100),
    manager_id INT
);

CREATE TABLE employees_3nf (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    department_id INT,
    salary DECIMAL(10,2),
    hire_date DATE,
    
    FOREIGN KEY (department_id) REFERENCES departments(id)
);

-- BCNF（Boyce-Codd范式）示例
CREATE TABLE course_instructors (
    course_id VARCHAR(10),
    instructor_id INT,
    semester VARCHAR(20),
    
    PRIMARY KEY (course_id, instructor_id, semester),
    
    -- 假设每个课程在每个学期只能有一个主讲教师
    UNIQUE KEY unique_course_semester (course_id, semester)
);
```

## 索引设计和优化

### 索引类型和使用

```sql
-- 主键索引（聚簇索引）
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'confirmed', 'shipped', 'delivered', 'cancelled'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 唯一索引
ALTER TABLE orders ADD UNIQUE INDEX idx_order_number (order_number);

-- 普通索引
ALTER TABLE orders ADD INDEX idx_user_id (user_id);
ALTER TABLE orders ADD INDEX idx_status (status);
ALTER TABLE orders ADD INDEX idx_created_at (created_at);

-- 复合索引
ALTER TABLE orders ADD INDEX idx_user_status_date (user_id, status, created_at);

-- 前缀索引
ALTER TABLE orders ADD INDEX idx_order_number_prefix (order_number(10));

-- 函数索引（MySQL 8.0+）
ALTER TABLE orders ADD INDEX idx_year_month ((YEAR(created_at)), (MONTH(created_at)));

-- 部分索引（条件索引）
-- PostgreSQL 示例
CREATE INDEX idx_active_orders ON orders (user_id, created_at) 
WHERE status IN ('pending', 'confirmed');

-- 覆盖索引示例
CREATE INDEX idx_order_summary ON orders (user_id, status) 
INCLUDE (total_amount, created_at);

-- 索引使用分析
EXPLAIN SELECT * FROM orders 
WHERE user_id = 12345 AND status = 'pending' 
ORDER BY created_at DESC 
LIMIT 10;

-- 索引优化建议查询
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    SEQ_IN_INDEX,
    CARDINALITY,
    SUB_PART
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;

-- 查找未使用的索引
SELECT 
    s.TABLE_SCHEMA,
    s.TABLE_NAME,
    s.INDEX_NAME,
    s.COLUMN_NAME
FROM information_schema.STATISTICS s
LEFT JOIN information_schema.INDEX_STATISTICS i 
    ON s.TABLE_SCHEMA = i.TABLE_SCHEMA 
    AND s.TABLE_NAME = i.TABLE_NAME 
    AND s.INDEX_NAME = i.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
    AND s.INDEX_NAME != 'PRIMARY'
    AND i.INDEX_NAME IS NULL;
```

### 查询优化

```sql
-- 查询优化示例

-- 1. 避免SELECT *
-- 不好的查询
SELECT * FROM orders WHERE user_id = 12345;

-- 好的查询
SELECT id, order_number, total_amount, status, created_at 
FROM orders 
WHERE user_id = 12345;

-- 2. 使用适当的WHERE条件
-- 不好的查询（无法使用索引）
SELECT * FROM orders WHERE YEAR(created_at) = 2024;

-- 好的查询（可以使用索引）
SELECT * FROM orders 
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';

-- 3. 优化JOIN查询
-- 不好的查询
SELECT o.*, u.username, u.email
FROM orders o, users u
WHERE o.user_id = u.id
    AND o.status = 'pending';

-- 好的查询
SELECT o.id, o.order_number, o.total_amount, u.username, u.email
FROM orders o
INNER JOIN users u ON o.user_id = u.id
WHERE o.status = 'pending'
    AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 4. 使用EXISTS代替IN（大数据集）
-- 不好的查询
SELECT * FROM users 
WHERE id IN (
    SELECT DISTINCT user_id FROM orders 
    WHERE created_at >= '2024-01-01'
);

-- 好的查询
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.user_id = u.id 
        AND o.created_at >= '2024-01-01'
);

-- 5. 分页优化
-- 不好的查询（OFFSET很大时性能差）
SELECT * FROM orders 
ORDER BY created_at DESC 
LIMIT 1000, 20;

-- 好的查询（使用游标分页）
SELECT * FROM orders 
WHERE created_at < '2024-01-01 12:00:00'
ORDER BY created_at DESC 
LIMIT 20;

-- 6. 聚合查询优化
-- 创建汇总表
CREATE TABLE order_daily_summary (
    date DATE PRIMARY KEY,
    total_orders INT DEFAULT 0,
    total_amount DECIMAL(12,2) DEFAULT 0,
    avg_order_amount DECIMAL(10,2) DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 使用触发器维护汇总表
DELIMITER //
CREATE TRIGGER update_daily_summary 
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    INSERT INTO order_daily_summary (date, total_orders, total_amount)
    VALUES (DATE(NEW.created_at), 1, NEW.total_amount)
    ON DUPLICATE KEY UPDATE
        total_orders = total_orders + 1,
        total_amount = total_amount + NEW.total_amount,
        avg_order_amount = total_amount / total_orders;
END//
DELIMITER ;

-- 7. 查询缓存和结果集缓存
-- 使用查询缓存（MySQL）
SELECT SQL_CACHE id, username FROM users WHERE status = 'active';

-- 8. 分区表优化
CREATE TABLE orders_partitioned (
    id BIGINT AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'confirmed', 'shipped', 'delivered', 'cancelled'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

## 数据库事务和并发控制

### 事务管理

```sql
-- 事务基础操作
START TRANSACTION;

-- 插入订单
INSERT INTO orders (user_id, total_amount, status) 
VALUES (12345, 99.99, 'pending');

SET @order_id = LAST_INSERT_ID();

-- 插入订单项
INSERT INTO order_items (order_id, product_id, quantity, unit_price)
VALUES 
    (@order_id, 1, 2, 29.99),
    (@order_id, 2, 1, 39.99);

-- 更新库存
UPDATE products SET stock_quantity = stock_quantity - 2 WHERE id = 1;
UPDATE products SET stock_quantity = stock_quantity - 1 WHERE id = 2;

-- 检查库存是否足够
SELECT COUNT(*) as insufficient_stock
FROM products 
WHERE id IN (1, 2) AND stock_quantity < 0;

-- 根据检查结果决定提交或回滚
-- 如果库存不足，回滚事务
-- ROLLBACK;

-- 如果一切正常，提交事务
COMMIT;

-- 事务隔离级别示例
-- 读未提交（READ UNCOMMITTED）
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1;
-- 可能读到其他事务未提交的数据
COMMIT;

-- 读已提交（READ COMMITTED）
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1;
-- 只能读到已提交的数据，但可能出现不可重复读
SELECT * FROM accounts WHERE id = 1; -- 可能与上次结果不同
COMMIT;

-- 可重复读（REPEATABLE READ）- MySQL默认级别
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1;
-- 在同一事务中多次读取结果一致
SELECT * FROM accounts WHERE id = 1; -- 与上次结果相同
COMMIT;

-- 串行化（SERIALIZABLE）
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT * FROM accounts WHERE balance > 1000;
-- 完全串行化执行，避免所有并发问题
COMMIT;
```

### 锁机制

```sql
-- 行级锁示例
-- 悲观锁：SELECT ... FOR UPDATE
START TRANSACTION;

SELECT balance FROM accounts 
WHERE id = 1 
FOR UPDATE; -- 锁定该行

-- 执行业务逻辑
UPDATE accounts 
SET balance = balance - 100 
WHERE id = 1;

COMMIT;

-- 共享锁：SELECT ... LOCK IN SHARE MODE
START TRANSACTION;

SELECT * FROM products 
WHERE id = 1 
LOCK IN SHARE MODE; -- 共享锁，允许其他事务读取但不能修改

-- 其他操作...

COMMIT;

-- 表级锁
LOCK TABLES orders WRITE, order_items WRITE;

-- 执行需要表级锁的操作
INSERT INTO orders (...) VALUES (...);
INSERT INTO order_items (...) VALUES (...);

UNLOCK TABLES;

-- 死锁检测和处理
-- MySQL会自动检测死锁并回滚其中一个事务

-- 查看当前锁状态
SHOW ENGINE INNODB STATUS;

-- 查看正在执行的事务
SELECT * FROM information_schema.INNODB_TRX;

-- 查看锁等待情况
SELECT * FROM information_schema.INNODB_LOCKS;
SELECT * FROM information_schema.INNODB_LOCK_WAITS;
```

### 乐观锁实现

```sql
-- 版本号乐观锁
CREATE TABLE products_optimistic (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INT NOT NULL DEFAULT 0,
    version INT NOT NULL DEFAULT 1, -- 版本号字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 乐观锁更新示例
-- 1. 先查询当前版本
SELECT id, stock_quantity, version 
FROM products_optimistic 
WHERE id = 1;

-- 假设查询结果：stock_quantity = 100, version = 5

-- 2. 更新时检查版本号
UPDATE products_optimistic 
SET stock_quantity = stock_quantity - 1,
    version = version + 1
WHERE id = 1 AND version = 5;

-- 3. 检查影响行数
-- 如果 ROW_COUNT() = 0，说明版本号已变化，更新失败
-- 如果 ROW_COUNT() = 1，说明更新成功

-- 时间戳乐观锁
CREATE TABLE orders_timestamp (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    status ENUM('pending', 'confirmed', 'cancelled'),
    total_amount DECIMAL(10,2),
    last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 使用时间戳进行乐观锁控制
UPDATE orders_timestamp 
SET status = 'confirmed',
    last_modified = NOW()
WHERE id = 1 
    AND last_modified = '2024-01-01 10:30:00'; -- 之前查询到的时间戳
```

## 数据库性能监控

### 性能指标监控

```sql
-- 查询性能统计
-- 慢查询日志分析
SHOW VARIABLES LIKE 'slow_query_log%';
SHOW VARIABLES LIKE 'long_query_time';

-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2; -- 记录执行时间超过2秒的查询

-- 查看查询缓存状态
SHOW VARIABLES LIKE 'query_cache%';
SHOW STATUS LIKE 'Qcache%';

-- 查看连接状态
SHOW STATUS LIKE 'Connections';
SHOW STATUS LIKE 'Max_used_connections';
SHOW PROCESSLIST;

-- 查看表状态
SHOW TABLE STATUS FROM your_database;

-- 分析表结构
ANALYZE TABLE orders;
OPTIMIZE TABLE orders;

-- 检查表的碎片化
SELECT 
    TABLE_NAME,
    ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 2) AS 'Size (MB)',
    ROUND((DATA_FREE / 1024 / 1024), 2) AS 'Free Space (MB)',
    ROUND((DATA_FREE / (DATA_LENGTH + INDEX_LENGTH)) * 100, 2) AS 'Fragmentation %'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'your_database'
    AND DATA_FREE > 0
ORDER BY `Fragmentation %` DESC;

-- 索引使用统计
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    CARDINALITY,
    SUB_PART,
    NULLABLE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;

-- 查询执行计划分析
EXPLAIN FORMAT=JSON 
SELECT o.*, u.username 
FROM orders o 
JOIN users u ON o.user_id = u.id 
WHERE o.created_at >= '2024-01-01' 
    AND o.status = 'pending'
ORDER BY o.created_at DESC 
LIMIT 10;

-- 性能模式查询（MySQL 5.7+）
-- 启用性能模式
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES' 
WHERE NAME LIKE '%statement/%';

UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%events_statements_%';

-- 查看最耗时的查询
SELECT 
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000000 AS avg_time_seconds,
    MAX_TIMER_WAIT/1000000000 AS max_time_seconds,
    SUM_TIMER_WAIT/1000000000 AS total_time_seconds
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;
```

### 数据库维护

```sql
-- 定期维护脚本

-- 1. 清理过期数据
-- 清理过期的会话
DELETE FROM user_sessions 
WHERE expires_at < NOW() - INTERVAL 1 DAY;

-- 清理旧的审计日志（保留1年）
DELETE FROM audit_logs 
WHERE created_at < NOW() - INTERVAL 1 YEAR;

-- 2. 更新表统计信息
ANALYZE TABLE users, orders, order_items, products;

-- 3. 优化表（重建索引，回收空间）
OPTIMIZE TABLE users, orders, order_items;

-- 4. 检查表完整性
CHECK TABLE users, orders, order_items;

-- 5. 备份重要数据
-- 创建备份表
CREATE TABLE users_backup_20240101 AS 
SELECT * FROM users 
WHERE created_at >= '2024-01-01' AND created_at < '2024-02-01';

-- 6. 分区维护（如果使用了分区表）
-- 添加新分区
ALTER TABLE orders_partitioned 
ADD PARTITION (PARTITION p2025 VALUES LESS THAN (2026));

-- 删除旧分区
ALTER TABLE orders_partitioned 
DROP PARTITION p2022;

-- 7. 索引维护
-- 重建索引
ALTER TABLE orders DROP INDEX idx_user_status_date;
ALTER TABLE orders ADD INDEX idx_user_status_date (user_id, status, created_at);

-- 8. 数据库配置优化
-- 查看当前配置
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
SHOW VARIABLES LIKE 'max_connections';
SHOW VARIABLES LIKE 'query_cache_size';

-- 动态调整配置（需要相应权限）
SET GLOBAL max_connections = 200;
SET GLOBAL query_cache_size = 67108864; -- 64MB
```

## 总结

数据库设计原理的核心要点：

1. **设计基础** - ER模型、范式理论、关系设计
2. **索引优化** - 索引类型选择、复合索引设计、查询优化
3. **事务管理** - ACID特性、隔离级别、并发控制
4. **性能优化** - 查询优化、分区策略、缓存机制
5. **监控维护** - 性能监控、定期维护、容量规划
6. **安全设计** - 权限控制、数据加密、审计日志

掌握这些原理将帮助你设计出高效、可靠、可扩展的数据库系统。