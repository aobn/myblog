---
title: "数据结构与算法"
excerpt: "深入学习数据结构与算法基础，掌握编程面试和系统设计的核心技能。"
author: "CodeBuddy"
category: "算法"
tags: ["数据结构", "算法", "编程面试", "计算机基础"]
publishedAt: "2024-05-25"
updatedAt: "2024-05-25"
readTime: 35
coverImage: "https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&h=400&fit=crop"
isPublished: true
---

# 数据结构与算法

数据结构与算法是计算机科学的基础，也是编程面试和系统设计的核心技能。本文将深入探讨常用的数据结构和算法，并提供实际的代码实现。

## 基础数据结构

### 数组和字符串

```python
# 数组操作基础
class ArrayOperations:
    def __init__(self):
        pass
    
    def two_sum(self, nums, target):
        """
        两数之和 - 哈希表解法
        时间复杂度: O(n), 空间复杂度: O(n)
        """
        hash_map = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in hash_map:
                return [hash_map[complement], i]
            hash_map[num] = i
        return []
    
    def max_subarray(self, nums):
        """
        最大子数组和 - Kadane算法
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        max_sum = current_sum = nums[0]
        
        for i in range(1, len(nums)):
            current_sum = max(nums[i], current_sum + nums[i])
            max_sum = max(max_sum, current_sum)
        
        return max_sum
    
    def merge_intervals(self, intervals):
        """
        合并区间
        时间复杂度: O(n log n), 空间复杂度: O(1)
        """
        if not intervals:
            return []
        
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            if current[0] <= last[1]:
                merged[-1] = [last[0], max(last[1], current[1])]
            else:
                merged.append(current)
        
        return merged
    
    def rotate_array(self, nums, k):
        """
        旋转数组
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        n = len(nums)
        k = k % n
        
        def reverse(start, end):
            while start < end:
                nums[start], nums[end] = nums[end], nums[start]
                start += 1
                end -= 1
        
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)

# 字符串操作
class StringOperations:
    def longest_substring_without_repeating(self, s):
        """
        无重复字符的最长子串 - 滑动窗口
        时间复杂度: O(n), 空间复杂度: O(min(m,n))
        """
        char_map = {}
        left = max_length = 0
        
        for right, char in enumerate(s):
            if char in char_map and char_map[char] >= left:
                left = char_map[char] + 1
            
            char_map[char] = right
            max_length = max(max_length, right - left + 1)
        
        return max_length
    
    def group_anagrams(self, strs):
        """
        字母异位词分组
        时间复杂度: O(n * k log k), 空间复杂度: O(n * k)
        """
        from collections import defaultdict
        
        groups = defaultdict(list)
        
        for s in strs:
            key = ''.join(sorted(s))
            groups[key].append(s)
        
        return list(groups.values())
    
    def is_palindrome(self, s):
        """
        验证回文串
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        left, right = 0, len(s) - 1
        
        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1
            
            if s[left].lower() != s[right].lower():
                return False
            
            left += 1
            right -= 1
        
        return True
```

### 链表

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedListOperations:
    def reverse_list(self, head):
        """
        反转链表
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        prev = None
        current = head
        
        while current:
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp
        
        return prev
    
    def merge_two_lists(self, l1, l2):
        """
        合并两个有序链表
        时间复杂度: O(n + m), 空间复杂度: O(1)
        """
        dummy = ListNode(0)
        current = dummy
        
        while l1 and l2:
            if l1.val <= l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next
        
        current.next = l1 or l2
        return dummy.next
    
    def has_cycle(self, head):
        """
        环形链表检测 - 快慢指针
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        if not head or not head.next:
            return False
        
        slow = fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
            if slow == fast:
                return True
        
        return False
    
    def find_cycle_start(self, head):
        """
        找到环形链表的起始节点
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        if not head or not head.next:
            return None
        
        # 第一阶段：检测是否有环
        slow = fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
            if slow == fast:
                break
        else:
            return None  # 无环
        
        # 第二阶段：找到环的起始点
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        
        return slow
    
    def remove_nth_from_end(self, head, n):
        """
        删除链表的倒数第N个节点
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        dummy = ListNode(0)
        dummy.next = head
        
        first = second = dummy
        
        # 移动first指针n+1步
        for _ in range(n + 1):
            first = first.next
        
        # 同时移动两个指针
        while first:
            first = first.next
            second = second.next
        
        # 删除节点
        second.next = second.next.next
        
        return dummy.next
```

### 栈和队列

```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("Stack is empty")
    
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        raise IndexError("Stack is empty")
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

class Queue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        self.items.insert(0, item)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("Queue is empty")
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# 使用栈解决的经典问题
class StackProblems:
    def is_valid_parentheses(self, s):
        """
        有效的括号
        时间复杂度: O(n), 空间复杂度: O(n)
        """
        stack = []
        mapping = {')': '(', '}': '{', ']': '['}
        
        for char in s:
            if char in mapping:
                if not stack or stack.pop() != mapping[char]:
                    return False
            else:
                stack.append(char)
        
        return not stack
    
    def daily_temperatures(self, temperatures):
        """
        每日温度 - 单调栈
        时间复杂度: O(n), 空间复杂度: O(n)
        """
        result = [0] * len(temperatures)
        stack = []  # 存储索引
        
        for i, temp in enumerate(temperatures):
            while stack and temperatures[stack[-1]] < temp:
                prev_index = stack.pop()
                result[prev_index] = i - prev_index
            stack.append(i)
        
        return result
    
    def largest_rectangle_area(self, heights):
        """
        柱状图中最大的矩形
        时间复杂度: O(n), 空间复杂度: O(n)
        """
        stack = []
        max_area = 0
        
        for i, h in enumerate(heights):
            while stack and heights[stack[-1]] > h:
                height = heights[stack.pop()]
                width = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, height * width)
            stack.append(i)
        
        while stack:
            height = heights[stack.pop()]
            width = len(heights) if not stack else len(heights) - stack[-1] - 1
            max_area = max(max_area, height * width)
        
        return max_area
```

## 树和图

### 二叉树

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinaryTreeOperations:
    def inorder_traversal(self, root):
        """
        中序遍历 - 递归
        时间复杂度: O(n), 空间复杂度: O(h)
        """
        result = []
        
        def inorder(node):
            if node:
                inorder(node.left)
                result.append(node.val)
                inorder(node.right)
        
        inorder(root)
        return result
    
    def inorder_iterative(self, root):
        """
        中序遍历 - 迭代
        时间复杂度: O(n), 空间复杂度: O(h)
        """
        result = []
        stack = []
        current = root
        
        while stack or current:
            while current:
                stack.append(current)
                current = current.left
            
            current = stack.pop()
            result.append(current.val)
            current = current.right
        
        return result
    
    def level_order_traversal(self, root):
        """
        层序遍历
        时间复杂度: O(n), 空间复杂度: O(w) w为最大宽度
        """
        if not root:
            return []
        
        from collections import deque
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            level = []
            
            for _ in range(level_size):
                node = queue.popleft()
                level.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(level)
        
        return result
    
    def max_depth(self, root):
        """
        二叉树的最大深度
        时间复杂度: O(n), 空间复杂度: O(h)
        """
        if not root:
            return 0
        
        return 1 + max(self.max_depth(root.left), self.max_depth(root.right))
    
    def is_valid_bst(self, root):
        """
        验证二叉搜索树
        时间复杂度: O(n), 空间复杂度: O(h)
        """
        def validate(node, min_val, max_val):
            if not node:
                return True
            
            if node.val <= min_val or node.val >= max_val:
                return False
            
            return (validate(node.left, min_val, node.val) and
                    validate(node.right, node.val, max_val))
        
        return validate(root, float('-inf'), float('inf'))
    
    def lowest_common_ancestor(self, root, p, q):
        """
        二叉树的最近公共祖先
        时间复杂度: O(n), 空间复杂度: O(h)
        """
        if not root or root == p or root == q:
            return root
        
        left = self.lowest_common_ancestor(root.left, p, q)
        right = self.lowest_common_ancestor(root.right, p, q)
        
        if left and right:
            return root
        
        return left or right
    
    def serialize(self, root):
        """
        序列化二叉树
        """
        def preorder(node):
            if not node:
                vals.append('#')
            else:
                vals.append(str(node.val))
                preorder(node.left)
                preorder(node.right)
        
        vals = []
        preorder(root)
        return ','.join(vals)
    
    def deserialize(self, data):
        """
        反序列化二叉树
        """
        def build():
            val = next(vals)
            if val == '#':
                return None
            
            node = TreeNode(int(val))
            node.left = build()
            node.right = build()
            return node
        
        vals = iter(data.split(','))
        return build()
```

### 图算法

```python
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
    
    def add_edge(self, u, v):
        self.graph[u].append(v)
    
    def dfs(self, start, visited=None):
        """
        深度优先搜索
        时间复杂度: O(V + E), 空间复杂度: O(V)
        """
        if visited is None:
            visited = set()
        
        visited.add(start)
        result = [start]
        
        for neighbor in self.graph[start]:
            if neighbor not in visited:
                result.extend(self.dfs(neighbor, visited))
        
        return result
    
    def bfs(self, start):
        """
        广度优先搜索
        时间复杂度: O(V + E), 空间复杂度: O(V)
        """
        visited = set()
        queue = deque([start])
        result = []
        
        visited.add(start)
        
        while queue:
            vertex = queue.popleft()
            result.append(vertex)
            
            for neighbor in self.graph[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return result
    
    def has_cycle(self):
        """
        检测有向图中的环
        时间复杂度: O(V + E), 空间复杂度: O(V)
        """
        WHITE, GRAY, BLACK = 0, 1, 2
        color = defaultdict(int)
        
        def dfs_visit(node):
            if color[node] == GRAY:
                return True  # 发现环
            
            if color[node] == BLACK:
                return False
            
            color[node] = GRAY
            
            for neighbor in self.graph[node]:
                if dfs_visit(neighbor):
                    return True
            
            color[node] = BLACK
            return False
        
        for node in self.graph:
            if color[node] == WHITE:
                if dfs_visit(node):
                    return True
        
        return False
    
    def topological_sort(self):
        """
        拓扑排序
        时间复杂度: O(V + E), 空间复杂度: O(V)
        """
        in_degree = defaultdict(int)
        
        # 计算入度
        for node in self.graph:
            for neighbor in self.graph[node]:
                in_degree[neighbor] += 1
        
        # 找到所有入度为0的节点
        queue = deque([node for node in self.graph if in_degree[node] == 0])
        result = []
        
        while queue:
            node = queue.popleft()
            result.append(node)
            
            for neighbor in self.graph[node]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result if len(result) == len(self.graph) else []

# 最短路径算法
class ShortestPath:
    def dijkstra(self, graph, start):
        """
        Dijkstra算法 - 单源最短路径
        时间复杂度: O((V + E) log V), 空间复杂度: O(V)
        """
        import heapq
        
        distances = {node: float('inf') for node in graph}
        distances[start] = 0
        pq = [(0, start)]
        visited = set()
        
        while pq:
            current_distance, current = heapq.heappop(pq)
            
            if current in visited:
                continue
            
            visited.add(current)
            
            for neighbor, weight in graph[current].items():
                distance = current_distance + weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        
        return distances
    
    def floyd_warshall(self, graph):
        """
        Floyd-Warshall算法 - 所有点对最短路径
        时间复杂度: O(V³), 空间复杂度: O(V²)
        """
        nodes = list(graph.keys())
        n = len(nodes)
        
        # 初始化距离矩阵
        dist = [[float('inf')] * n for _ in range(n)]
        
        # 设置直接连接的距离
        for i, u in enumerate(nodes):
            dist[i][i] = 0
            for j, v in enumerate(nodes):
                if v in graph[u]:
                    dist[i][j] = graph[u][v]
        
        # Floyd-Warshall核心算法
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
        
        return dist
```

## 动态规划

```python
class DynamicProgramming:
    def fibonacci(self, n):
        """
        斐波那契数列
        时间复杂度: O(n), 空间复杂度: O(1)
        """
        if n <= 1:
            return n
        
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        
        return b
    
    def coin_change(self, coins, amount):
        """
        零钱兑换
        时间复杂度: O(amount * len(coins)), 空间复杂度: O(amount)
        """
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for i in range(1, amount + 1):
            for coin in coins:
                if coin <= i:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        
        return dp[amount] if dp[amount] != float('inf') else -1
    
    def longest_increasing_subsequence(self, nums):
        """
        最长递增子序列
        时间复杂度: O(n log n), 空间复杂度: O(n)
        """
        if not nums:
            return 0
        
        import bisect
        
        tails = []
        
        for num in nums:
            pos = bisect.bisect_left(tails, num)
            if pos == len(tails):
                tails.append(num)
            else:
                tails[pos] = num
        
        return len(tails)
    
    def edit_distance(self, word1, word2):
        """
        编辑距离
        时间复杂度: O(m * n), 空间复杂度: O(m * n)
        """
        m, n = len(word1), len(word2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # 初始化边界条件
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = 1 + min(
                        dp[i - 1][j],      # 删除
                        dp[i][j - 1],      # 插入
                        dp[i - 1][j - 1]   # 替换
                    )
        
        return dp[m][n]
    
    def knapsack_01(self, weights, values, capacity):
        """
        0-1背包问题
        时间复杂度: O(n * capacity), 空间复杂度: O(capacity)
        """
        n = len(weights)
        dp = [0] * (capacity + 1)
        
        for i in range(n):
            for w in range(capacity, weights[i] - 1, -1):
                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
        
        return dp[capacity]
    
    def longest_common_subsequence(self, text1, text2):
        """
        最长公共子序列
        时间复杂度: O(m * n), 空间复杂度: O(m * n)
        """
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n]
```

## 排序算法

```python
class SortingAlgorithms:
    def quick_sort(self, arr):
        """
        快速排序
        平均时间复杂度: O(n log n), 最坏: O(n²), 空间复杂度: O(log n)
        """
        if len(arr) <= 1:
            return arr
        
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        
        return self.quick_sort(left) + middle + self.quick_sort(right)
    
    def merge_sort(self, arr):
        """
        归并排序
        时间复杂度: O(n log n), 空间复杂度: O(n)
        """
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = self.merge_sort(arr[:mid])
        right = self.merge_sort(arr[mid:])
        
        return self.merge(left, right)
    
    def merge(self, left, right):
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    def heap_sort(self, arr):
        """
        堆排序
        时间复杂度: O(n log n), 空间复杂度: O(1)
        """
        def heapify(arr, n, i):
            largest = i
            left = 2 * i + 1
            right = 2 * i + 2
            
            if left < n and arr[left] > arr[largest]:
                largest = left
            
            if right < n and arr[right] > arr[largest]:
                largest = right
            
            if largest != i:
                arr[i], arr[largest] = arr[largest], arr[i]
                heapify(arr, n, largest)
        
        n = len(arr)
        
        # 构建最大堆
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # 逐个提取元素
        for i in range(n - 1, 0, -1):
            arr[0], arr[i] = arr[i], arr[0]
            heapify(arr, i, 0)
        
        return arr
    
    def counting_sort(self, arr):
        """
        计数排序
        时间复杂度: O(n + k), 空间复杂度: O(k)
        """
        if not arr:
            return arr
        
        max_val = max(arr)
        min_val = min(arr)
        range_val = max_val - min_val + 1
        
        count = [0] * range_val
        output = [0] * len(arr)
        
        # 计数
        for num in arr:
            count[num - min_val] += 1
        
        # 累积计数
        for i in range(1, range_val):
            count[i] += count[i - 1]
        
        # 构建输出数组
        for i in range(len(arr) - 1, -1, -1):
            output[count[arr[i] - min_val] - 1] = arr[i]
            count[arr[i] - min_val] -= 1
        
        return output
```

## 总结

数据结构与算法的核心要点：

1. **基础数据结构** - 数组、链表、栈、队列的操作和应用
2. **树和图** - 二叉树遍历、图的搜索和最短路径算法
3. **动态规划** - 状态转移方程的设计和优化
4. **排序算法** - 各种排序算法的时间空间复杂度分析
5. **算法设计** - 分治、贪心、回溯等算法设计思想
6. **复杂度分析** - 时间复杂度和空间复杂度的计算

掌握这些基础知识将为你的编程能力和系统设计能力打下坚实的基础。