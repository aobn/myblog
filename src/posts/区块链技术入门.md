---
title: "区块链技术入门"
excerpt: "深入学习区块链核心技术，从基础概念到智能合约开发。"
author: "CodeBuddy"
category: "区块链"
tags: ["区块链", "智能合约", "Web3", "Solidity"]
publishedAt: "2024-06-15"
updatedAt: "2024-06-15"
readTime: 26
coverImage: "https://images.unsplash.com/photo-1639762681485-074b7f938ba0?w=800&h=400&fit=crop"
isPublished: true
---

# 区块链技术入门

区块链是一种分布式账本技术，为数字货币和去中心化应用提供了基础。本文将深入探讨区块链的核心概念和实际应用。

## 区块链基础概念

### 区块结构

```python
import hashlib
import json
from time import time

class Block:
    def __init__(self, index, transactions, timestamp, previous_hash, nonce=0):
        self.index = index
        self.transactions = transactions
        self.timestamp = timestamp
        self.previous_hash = previous_hash
        self.nonce = nonce
        self.hash = self.calculate_hash()
    
    def calculate_hash(self):
        """计算区块哈希"""
        block_string = json.dumps({
            "index": self.index,
            "transactions": self.transactions,
            "timestamp": self.timestamp,
            "previous_hash": self.previous_hash,
            "nonce": self.nonce
        }, sort_keys=True)
        
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def mine_block(self, difficulty):
        """挖矿 - 工作量证明"""
        target = "0" * difficulty
        
        while self.hash[:difficulty] != target:
            self.nonce += 1
            self.hash = self.calculate_hash()
        
        print(f"Block mined: {self.hash}")
    
    def to_dict(self):
        return {
            "index": self.index,
            "transactions": self.transactions,
            "timestamp": self.timestamp,
            "previous_hash": self.previous_hash,
            "nonce": self.nonce,
            "hash": self.hash
        }
```

### 区块链实现

```python
class Blockchain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]
        self.difficulty = 2
        self.pending_transactions = []
        self.mining_reward = 100
    
    def create_genesis_block(self):
        """创建创世区块"""
        return Block(0, [], time(), "0")
    
    def get_latest_block(self):
        """获取最新区块"""
        return self.chain[-1]
    
    def add_transaction(self, transaction):
        """添加交易到待处理列表"""
        self.pending_transactions.append(transaction)
    
    def mine_pending_transactions(self, mining_reward_address):
        """挖掘待处理的交易"""
        # 添加挖矿奖励交易
        reward_transaction = Transaction(None, mining_reward_address, self.mining_reward)
        self.pending_transactions.append(reward_transaction)
        
        # 创建新区块
        block = Block(
            len(self.chain),
            self.pending_transactions,
            time(),
            self.get_latest_block().hash
        )
        
        # 挖矿
        block.mine_block(self.difficulty)
        
        # 添加到链中
        self.chain.append(block)
        
        # 清空待处理交易
        self.pending_transactions = []
    
    def get_balance(self, address):
        """获取地址余额"""
        balance = 0
        
        for block in self.chain:
            for transaction in block.transactions:
                if hasattr(transaction, 'from_address') and transaction.from_address == address:
                    balance -= transaction.amount
                
                if hasattr(transaction, 'to_address') and transaction.to_address == address:
                    balance += transaction.amount
        
        return balance
    
    def is_chain_valid(self):
        """验证区块链有效性"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]
            
            # 验证当前区块哈希
            if current_block.hash != current_block.calculate_hash():
                return False
            
            # 验证前一个区块哈希
            if current_block.previous_hash != previous_block.hash:
                return False
        
        return True
    
    def to_dict(self):
        return [block.to_dict() for block in self.chain]

class Transaction:
    def __init__(self, from_address, to_address, amount):
        self.from_address = from_address
        self.to_address = to_address
        self.amount = amount
        self.timestamp = time()
    
    def calculate_hash(self):
        """计算交易哈希"""
        transaction_string = json.dumps({
            "from_address": self.from_address,
            "to_address": self.to_address,
            "amount": self.amount,
            "timestamp": self.timestamp
        }, sort_keys=True)
        
        return hashlib.sha256(transaction_string.encode()).hexdigest()
```

## 智能合约开发

### Solidity 基础

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleToken {
    // 状态变量
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    
    // 余额映射
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    // 事件
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    // 构造函数
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        uint256 _totalSupply
    ) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply * 10**_decimals;
        balanceOf[msg.sender] = totalSupply;
    }
    
    // 转账函数
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), "Invalid address");
        require(balanceOf[msg.sender] >= _value, "Insufficient balance");
        
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    
    // 授权函数
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    // 代理转账
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), "Invalid address");
        require(balanceOf[_from] >= _value, "Insufficient balance");
        require(allowance[_from][msg.sender] >= _value, "Insufficient allowance");
        
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        
        emit Transfer(_from, _to, _value);
        return true;
    }
}
```

### 高级智能合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract NFTMarketplace is ERC721, Ownable {
    using Counters for Counters.Counter;
    
    Counters.Counter private _tokenIds;
    Counters.Counter private _itemsSold;
    
    uint256 listingPrice = 0.025 ether;
    
    struct MarketItem {
        uint256 tokenId;
        address payable seller;
        address payable owner;
        uint256 price;
        bool sold;
    }
    
    mapping(uint256 => MarketItem) private idToMarketItem;
    
    event MarketItemCreated(
        uint256 indexed tokenId,
        address seller,
        address owner,
        uint256 price,
        bool sold
    );
    
    constructor() ERC721("NFT Marketplace", "NFTM") {}
    
    function updateListingPrice(uint _listingPrice) public payable onlyOwner {
        listingPrice = _listingPrice;
    }
    
    function getListingPrice() public view returns (uint256) {
        return listingPrice;
    }
    
    function createToken(string memory tokenURI, uint256 price) public payable returns (uint) {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        _mint(msg.sender, newTokenId);
        _setTokenURI(newTokenId, tokenURI);
        createMarketItem(newTokenId, price);
        
        return newTokenId;
    }
    
    function createMarketItem(uint256 tokenId, uint256 price) private {
        require(price > 0, "Price must be at least 1 wei");
        require(msg.value == listingPrice, "Price must be equal to listing price");
        
        idToMarketItem[tokenId] = MarketItem(
            tokenId,
            payable(msg.sender),
            payable(address(this)),
            price,
            false
        );
        
        _transfer(msg.sender, address(this), tokenId);
        
        emit MarketItemCreated(
            tokenId,
            msg.sender,
            address(this),
            price,
            false
        );
    }
    
    function createMarketSale(uint256 tokenId) public payable {
        uint price = idToMarketItem[tokenId].price;
        address seller = idToMarketItem[tokenId].seller;
        
        require(msg.value == price, "Please submit the asking price");
        
        idToMarketItem[tokenId].owner = payable(msg.sender);
        idToMarketItem[tokenId].sold = true;
        idToMarketItem[tokenId].seller = payable(address(0));
        
        _itemsSold.increment();
        _transfer(address(this), msg.sender, tokenId);
        
        payable(owner()).transfer(listingPrice);
        payable(seller).transfer(msg.value);
    }
    
    function fetchMarketItems() public view returns (MarketItem[] memory) {
        uint itemCount = _tokenIds.current();
        uint unsoldItemCount = _tokenIds.current() - _itemsSold.current();
        uint currentIndex = 0;
        
        MarketItem[] memory items = new MarketItem[](unsoldItemCount);
        
        for (uint i = 0; i < itemCount; i++) {
            if (idToMarketItem[i + 1].owner == address(this)) {
                uint currentId = i + 1;
                MarketItem storage currentItem = idToMarketItem[currentId];
                items[currentIndex] = currentItem;
                currentIndex += 1;
            }
        }
        
        return items;
    }
    
    function fetchMyNFTs() public view returns (MarketItem[] memory) {
        uint totalItemCount = _tokenIds.current();
        uint itemCount = 0;
        uint currentIndex = 0;
        
        for (uint i = 0; i < totalItemCount; i++) {
            if (idToMarketItem[i + 1].owner == msg.sender) {
                itemCount += 1;
            }
        }
        
        MarketItem[] memory items = new MarketItem[](itemCount);
        
        for (uint i = 0; i < totalItemCount; i++) {
            if (idToMarketItem[i + 1].owner == msg.sender) {
                uint currentId = i + 1;
                MarketItem storage currentItem = idToMarketItem[currentId];
                items[currentIndex] = currentItem;
                currentIndex += 1;
            }
        }
        
        return items;
    }
}
```

## Web3 应用开发

### 前端集成

```javascript
// web3-integration.js
import Web3 from 'web3';
import { ethers } from 'ethers';

class Web3Service {
    constructor() {
        this.web3 = null;
        this.provider = null;
        this.signer = null;
        this.account = null;
    }
    
    async connectWallet() {
        if (typeof window.ethereum !== 'undefined') {
            try {
                // 请求连接钱包
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                // 初始化 Web3
                this.web3 = new Web3(window.ethereum);
                this.provider = new ethers.providers.Web3Provider(window.ethereum);
                this.signer = this.provider.getSigner();
                
                // 获取账户
                const accounts = await this.web3.eth.getAccounts();
                this.account = accounts[0];
                
                console.log('Connected to wallet:', this.account);
                return this.account;
            } catch (error) {
                console.error('Failed to connect wallet:', error);
                throw error;
            }
        } else {
            throw new Error('MetaMask is not installed');
        }
    }
    
    async getBalance(address = this.account) {
        if (!this.web3) throw new Error('Web3 not initialized');
        
        const balance = await this.web3.eth.getBalance(address);
        return this.web3.utils.fromWei(balance, 'ether');
    }
    
    async sendTransaction(to, amount) {
        if (!this.web3 || !this.account) throw new Error('Wallet not connected');
        
        const transaction = {
            from: this.account,
            to: to,
            value: this.web3.utils.toWei(amount.toString(), 'ether'),
            gas: 21000,
            gasPrice: await this.web3.eth.getGasPrice()
        };
        
        try {
            const result = await this.web3.eth.sendTransaction(transaction);
            console.log('Transaction sent:', result.transactionHash);
            return result;
        } catch (error) {
            console.error('Transaction failed:', error);
            throw error;
        }
    }
    
    async deployContract(abi, bytecode, constructorArgs = []) {
        if (!this.signer) throw new Error('Signer not available');
        
        const factory = new ethers.ContractFactory(abi, bytecode, this.signer);
        
        try {
            const contract = await factory.deploy(...constructorArgs);
            await contract.deployed();
            
            console.log('Contract deployed at:', contract.address);
            return contract;
        } catch (error) {
            console.error('Contract deployment failed:', error);
            throw error;
        }
    }
    
    async interactWithContract(contractAddress, abi) {
        if (!this.signer) throw new Error('Signer not available');
        
        return new ethers.Contract(contractAddress, abi, this.signer);
    }
    
    async listenToEvents(contract, eventName, callback) {
        contract.on(eventName, callback);
    }
    
    async getTransactionReceipt(txHash) {
        if (!this.web3) throw new Error('Web3 not initialized');
        
        return await this.web3.eth.getTransactionReceipt(txHash);
    }
    
    async switchNetwork(chainId) {
        try {
            await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: `0x${chainId.toString(16)}` }],
            });
        } catch (switchError) {
            // 如果网络不存在，添加网络
            if (switchError.code === 4902) {
                await this.addNetwork(chainId);
            } else {
                throw switchError;
            }
        }
    }
    
    async addNetwork(chainId) {
        const networkConfig = this.getNetworkConfig(chainId);
        
        await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [networkConfig],
        });
    }
    
    getNetworkConfig(chainId) {
        const configs = {
            137: { // Polygon
                chainId: '0x89',
                chainName: 'Polygon Mainnet',
                nativeCurrency: {
                    name: 'MATIC',
                    symbol: 'MATIC',
                    decimals: 18,
                },
                rpcUrls: ['https://polygon-rpc.com/'],
                blockExplorerUrls: ['https://polygonscan.com/'],
            },
            56: { // BSC
                chainId: '0x38',
                chainName: 'Binance Smart Chain',
                nativeCurrency: {
                    name: 'BNB',
                    symbol: 'BNB',
                    decimals: 18,
                },
                rpcUrls: ['https://bsc-dataseed.binance.org/'],
                blockExplorerUrls: ['https://bscscan.com/'],
            },
        };
        
        return configs[chainId];
    }
}

// React Hook 示例
import { useState, useEffect } from 'react';

export const useWeb3 = () => {
    const [web3Service, setWeb3Service] = useState(null);
    const [account, setAccount] = useState(null);
    const [balance, setBalance] = useState('0');
    const [isConnected, setIsConnected] = useState(false);
    
    useEffect(() => {
        const service = new Web3Service();
        setWeb3Service(service);
        
        // 检查是否已连接
        if (window.ethereum && window.ethereum.selectedAddress) {
            connectWallet();
        }
        
        // 监听账户变化
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);
        }
        
        return () => {
            if (window.ethereum) {
                window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                window.ethereum.removeListener('chainChanged', handleChainChanged);
            }
        };
    }, []);
    
    const connectWallet = async () => {
        try {
            const account = await web3Service.connectWallet();
            setAccount(account);
            setIsConnected(true);
            
            const balance = await web3Service.getBalance(account);
            setBalance(balance);
        } catch (error) {
            console.error('Failed to connect wallet:', error);
        }
    };
    
    const handleAccountsChanged = (accounts) => {
        if (accounts.length === 0) {
            setAccount(null);
            setIsConnected(false);
            setBalance('0');
        } else {
            setAccount(accounts[0]);
            updateBalance(accounts[0]);
        }
    };
    
    const handleChainChanged = () => {
        window.location.reload();
    };
    
    const updateBalance = async (address) => {
        if (web3Service) {
            const balance = await web3Service.getBalance(address);
            setBalance(balance);
        }
    };
    
    return {
        web3Service,
        account,
        balance,
        isConnected,
        connectWallet,
        updateBalance,
    };
};
```

## DeFi 协议开发

### 去中心化交易所 (DEX)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SimpleDEX is ReentrancyGuard {
    struct Pool {
        address tokenA;
        address tokenB;
        uint256 reserveA;
        uint256 reserveB;
        uint256 totalLiquidity;
        mapping(address => uint256) liquidity;
    }
    
    mapping(bytes32 => Pool) public pools;
    mapping(address => mapping(address => bytes32)) public getPoolId;
    
    event PoolCreated(address indexed tokenA, address indexed tokenB, bytes32 poolId);
    event LiquidityAdded(bytes32 indexed poolId, address indexed provider, uint256 amountA, uint256 amountB);
    event LiquidityRemoved(bytes32 indexed poolId, address indexed provider, uint256 amountA, uint256 amountB);
    event Swap(bytes32 indexed poolId, address indexed user, address tokenIn, uint256 amountIn, uint256 amountOut);
    
    function createPool(address tokenA, address tokenB) external returns (bytes32 poolId) {
        require(tokenA != tokenB, "Identical tokens");
        require(tokenA != address(0) && tokenB != address(0), "Zero address");
        
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(getPoolId[token0][token1] == bytes32(0), "Pool exists");
        
        poolId = keccak256(abi.encodePacked(token0, token1));
        
        Pool storage pool = pools[poolId];
        pool.tokenA = token0;
        pool.tokenB = token1;
        
        getPoolId[token0][token1] = poolId;
        getPoolId[token1][token0] = poolId;
        
        emit PoolCreated(token0, token1, poolId);
    }
    
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountA,
        uint256 amountB
    ) external nonReentrant {
        bytes32 poolId = getPoolId[tokenA][tokenB];
        require(poolId != bytes32(0), "Pool does not exist");
        
        Pool storage pool = pools[poolId];
        
        if (pool.totalLiquidity == 0) {
            // 首次添加流动性
            require(amountA > 0 && amountB > 0, "Insufficient amounts");
            
            IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);
            IERC20(tokenB).transferFrom(msg.sender, address(this), amountB);
            
            pool.reserveA = amountA;
            pool.reserveB = amountB;
            
            uint256 liquidity = sqrt(amountA * amountB);
            pool.totalLiquidity = liquidity;
            pool.liquidity[msg.sender] = liquidity;
        } else {
            // 按比例添加流动性
            uint256 amountBOptimal = (amountA * pool.reserveB) / pool.reserveA;
            require(amountBOptimal <= amountB, "Insufficient B amount");
            
            IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);
            IERC20(tokenB).transferFrom(msg.sender, address(this), amountBOptimal);
            
            uint256 liquidity = (amountA * pool.totalLiquidity) / pool.reserveA;
            
            pool.reserveA += amountA;
            pool.reserveB += amountBOptimal;
            pool.totalLiquidity += liquidity;
            pool.liquidity[msg.sender] += liquidity;
            
            amountB = amountBOptimal;
        }
        
        emit LiquidityAdded(poolId, msg.sender, amountA, amountB);
    }
    
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity
    ) external nonReentrant {
        bytes32 poolId = getPoolId[tokenA][tokenB];
        require(poolId != bytes32(0), "Pool does not exist");
        
        Pool storage pool = pools[poolId];
        require(pool.liquidity[msg.sender] >= liquidity, "Insufficient liquidity");
        
        uint256 amountA = (liquidity * pool.reserveA) / pool.totalLiquidity;
        uint256 amountB = (liquidity * pool.reserveB) / pool.totalLiquidity;
        
        pool.liquidity[msg.sender] -= liquidity;
        pool.totalLiquidity -= liquidity;
        pool.reserveA -= amountA;
        pool.reserveB -= amountB;
        
        IERC20(pool.tokenA).transfer(msg.sender, amountA);
        IERC20(pool.tokenB).transfer(msg.sender, amountB);
        
        emit LiquidityRemoved(poolId, msg.sender, amountA, amountB);
    }
    
    function swap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut
    ) external nonReentrant {
        bytes32 poolId = getPoolId[tokenIn][tokenOut];
        require(poolId != bytes32(0), "Pool does not exist");
        
        Pool storage pool = pools[poolId];
        
        bool isTokenA = tokenIn == pool.tokenA;
        (uint256 reserveIn, uint256 reserveOut) = isTokenA 
            ? (pool.reserveA, pool.reserveB) 
            : (pool.reserveB, pool.reserveA);
        
        uint256 amountOut = getAmountOut(amountIn, reserveIn, reserveOut);
        require(amountOut >= minAmountOut, "Insufficient output amount");
        
        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(tokenOut).transfer(msg.sender, amountOut);
        
        if (isTokenA) {
            pool.reserveA += amountIn;
            pool.reserveB -= amountOut;
        } else {
            pool.reserveB += amountIn;
            pool.reserveA -= amountOut;
        }
        
        emit Swap(poolId, msg.sender, tokenIn, amountIn, amountOut);
    }
    
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 amountOut) {
        require(amountIn > 0, "Insufficient input amount");
        require(reserveIn > 0 && reserveOut > 0, "Insufficient liquidity");
        
        uint256 amountInWithFee = amountIn * 997; // 0.3% fee
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = (reserveIn * 1000) + amountInWithFee;
        amountOut = numerator / denominator;
    }
    
    function sqrt(uint256 x) internal pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}
```

## 总结

区块链技术的核心要点：

1. **基础概念** - 区块、哈希、共识机制
2. **智能合约** - Solidity 开发和最佳实践
3. **Web3 集成** - 前端与区块链交互
4. **DeFi 协议** - 去中心化金融应用
5. **安全考虑** - 智能合约安全和审计
6. **扩展性** - Layer 2 解决方案

掌握这些技能将让你能够开发完整的区块链应用。