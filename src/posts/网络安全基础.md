---
title: "网络安全基础"
excerpt: "深入学习网络安全基础知识，掌握常见的安全威胁和防护措施。"
author: "CodeBuddy"
category: "安全"
tags: ["网络安全", "加密", "认证", "防护"]
publishedAt: "2024-07-14"
updatedAt: "2024-07-14"
readTime: 28
coverImage: "https://images.unsplash.com/photo-1563013544-824ae1b704d3?w=800&h=400&fit=crop"
isPublished: true
---

# 网络安全基础

网络安全是保护网络系统和数据免受未授权访问、使用、披露、破坏、修改或销毁的实践。本文将深入探讨网络安全的基础知识和实践方法。

## 加密技术

### 对称加密

```python
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os

class SymmetricEncryption:
    def __init__(self):
        self.key = None
    
    def generate_key(self):
        """生成对称加密密钥"""
        self.key = Fernet.generate_key()
        return self.key
    
    def encrypt_data(self, data, key=None):
        """使用Fernet加密数据"""
        if key is None:
            key = self.key
        
        f = Fernet(key)
        encrypted_data = f.encrypt(data.encode())
        return encrypted_data
    
    def decrypt_data(self, encrypted_data, key=None):
        """解密数据"""
        if key is None:
            key = self.key
        
        f = Fernet(key)
        decrypted_data = f.decrypt(encrypted_data)
        return decrypted_data.decode()
    
    def aes_encrypt(self, plaintext, key):
        """AES加密示例"""
        # 生成随机IV
        iv = os.urandom(16)
        
        # 创建加密器
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        
        # 填充数据到16字节的倍数
        padded_data = self._pad_data(plaintext.encode())
        
        # 加密
        ciphertext = encryptor.update(padded_data) + encryptor.finalize()
        
        return iv + ciphertext
    
    def aes_decrypt(self, ciphertext, key):
        """AES解密"""
        # 提取IV
        iv = ciphertext[:16]
        actual_ciphertext = ciphertext[16:]
        
        # 创建解密器
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        
        # 解密
        padded_plaintext = decryptor.update(actual_ciphertext) + decryptor.finalize()
        
        # 去除填充
        plaintext = self._unpad_data(padded_plaintext)
        
        return plaintext.decode()
    
    def _pad_data(self, data):
        """PKCS7填充"""
        padding_length = 16 - (len(data) % 16)
        padding = bytes([padding_length] * padding_length)
        return data + padding
    
    def _unpad_data(self, padded_data):
        """去除PKCS7填充"""
        padding_length = padded_data[-1]
        return padded_data[:-padding_length]

# 使用示例
def symmetric_encryption_example():
    encryptor = SymmetricEncryption()
    
    # 生成密钥
    key = encryptor.generate_key()
    print(f"Generated key: {key}")
    
    # 加密数据
    original_data = "This is sensitive information"
    encrypted = encryptor.encrypt_data(original_data)
    print(f"Encrypted: {encrypted}")
    
    # 解密数据
    decrypted = encryptor.decrypt_data(encrypted)
    print(f"Decrypted: {decrypted}")
    
    # AES加密示例
    aes_key = os.urandom(32)  # 256位密钥
    aes_encrypted = encryptor.aes_encrypt(original_data, aes_key)
    aes_decrypted = encryptor.aes_decrypt(aes_encrypted, aes_key)
    print(f"AES Decrypted: {aes_decrypted}")
```

### 非对称加密

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.backends import default_backend

class AsymmetricEncryption:
    def __init__(self):
        self.private_key = None
        self.public_key = None
    
    def generate_key_pair(self, key_size=2048):
        """生成RSA密钥对"""
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=default_backend()
        )
        self.public_key = self.private_key.public_key()
        
        return self.private_key, self.public_key
    
    def encrypt_with_public_key(self, message, public_key=None):
        """使用公钥加密"""
        if public_key is None:
            public_key = self.public_key
        
        encrypted = public_key.encrypt(
            message.encode(),
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return encrypted
    
    def decrypt_with_private_key(self, encrypted_message, private_key=None):
        """使用私钥解密"""
        if private_key is None:
            private_key = self.private_key
        
        decrypted = private_key.decrypt(
            encrypted_message,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return decrypted.decode()
    
    def sign_message(self, message, private_key=None):
        """数字签名"""
        if private_key is None:
            private_key = self.private_key
        
        signature = private_key.sign(
            message.encode(),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return signature
    
    def verify_signature(self, message, signature, public_key=None):
        """验证数字签名"""
        if public_key is None:
            public_key = self.public_key
        
        try:
            public_key.verify(
                signature,
                message.encode(),
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except Exception:
            return False
    
    def export_private_key(self, password=None):
        """导出私钥"""
        if password:
            encryption_algorithm = serialization.BestAvailableEncryption(password.encode())
        else:
            encryption_algorithm = serialization.NoEncryption()
        
        pem = self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=encryption_algorithm
        )
        return pem
    
    def export_public_key(self):
        """导出公钥"""
        pem = self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        return pem
    
    def load_private_key(self, pem_data, password=None):
        """加载私钥"""
        if password:
            password = password.encode()
        
        self.private_key = serialization.load_pem_private_key(
            pem_data,
            password=password,
            backend=default_backend()
        )
        self.public_key = self.private_key.public_key()
    
    def load_public_key(self, pem_data):
        """加载公钥"""
        self.public_key = serialization.load_pem_public_key(
            pem_data,
            backend=default_backend()
        )
```

## 哈希和数字签名

```python
import hashlib
import hmac
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

class HashingAndSigning:
    def __init__(self):
        pass
    
    def calculate_hash(self, data, algorithm='sha256'):
        """计算哈希值"""
        if isinstance(data, str):
            data = data.encode()
        
        if algorithm == 'md5':
            return hashlib.md5(data).hexdigest()
        elif algorithm == 'sha1':
            return hashlib.sha1(data).hexdigest()
        elif algorithm == 'sha256':
            return hashlib.sha256(data).hexdigest()
        elif algorithm == 'sha512':
            return hashlib.sha512(data).hexdigest()
        else:
            raise ValueError(f"Unsupported algorithm: {algorithm}")
    
    def calculate_file_hash(self, file_path, algorithm='sha256'):
        """计算文件哈希值"""
        hash_func = getattr(hashlib, algorithm)()
        
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_func.update(chunk)
        
        return hash_func.hexdigest()
    
    def calculate_hmac(self, data, key, algorithm='sha256'):
        """计算HMAC"""
        if isinstance(data, str):
            data = data.encode()
        if isinstance(key, str):
            key = key.encode()
        
        if algorithm == 'sha256':
            return hmac.new(key, data, hashlib.sha256).hexdigest()
        elif algorithm == 'sha512':
            return hmac.new(key, data, hashlib.sha512).hexdigest()
        else:
            raise ValueError(f"Unsupported algorithm: {algorithm}")
    
    def verify_hmac(self, data, key, expected_hmac, algorithm='sha256'):
        """验证HMAC"""
        calculated_hmac = self.calculate_hmac(data, key, algorithm)
        return hmac.compare_digest(calculated_hmac, expected_hmac)
    
    def password_hash(self, password, salt=None):
        """密码哈希（使用PBKDF2）"""
        import os
        from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
        
        if salt is None:
            salt = os.urandom(32)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        
        key = kdf.derive(password.encode())
        return salt + key
    
    def verify_password(self, password, hashed_password):
        """验证密码"""
        salt = hashed_password[:32]
        key = hashed_password[32:]
        
        from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        
        try:
            kdf.verify(password.encode(), key)
            return True
        except Exception:
            return False

# 使用示例
def hashing_example():
    hasher = HashingAndSigning()
    
    # 计算哈希
    data = "Hello, World!"
    sha256_hash = hasher.calculate_hash(data, 'sha256')
    print(f"SHA256: {sha256_hash}")
    
    # 计算HMAC
    key = "secret_key"
    hmac_value = hasher.calculate_hmac(data, key)
    print(f"HMAC: {hmac_value}")
    
    # 验证HMAC
    is_valid = hasher.verify_hmac(data, key, hmac_value)
    print(f"HMAC Valid: {is_valid}")
    
    # 密码哈希
    password = "my_secure_password"
    hashed = hasher.password_hash(password)
    print(f"Password hashed: {len(hashed)} bytes")
    
    # 验证密码
    is_correct = hasher.verify_password(password, hashed)
    print(f"Password correct: {is_correct}")
```

## 网络安全协议

### TLS/SSL 实现

```python
import ssl
import socket
from urllib.parse import urlparse

class TLSClient:
    def __init__(self):
        self.context = ssl.create_default_context()
    
    def create_secure_connection(self, hostname, port=443):
        """创建安全连接"""
        # 创建SSL上下文
        context = ssl.create_default_context()
        
        # 可选：设置证书验证模式
        context.check_hostname = True
        context.verify_mode = ssl.CERT_REQUIRED
        
        # 创建socket连接
        sock = socket.create_connection((hostname, port))
        
        # 包装为SSL socket
        ssock = context.wrap_socket(sock, server_hostname=hostname)
        
        return ssock
    
    def get_certificate_info(self, hostname, port=443):
        """获取证书信息"""
        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    return {
                        'subject': dict(x[0] for x in cert['subject']),
                        'issuer': dict(x[0] for x in cert['issuer']),
                        'version': cert['version'],
                        'serial_number': cert['serialNumber'],
                        'not_before': cert['notBefore'],
                        'not_after': cert['notAfter'],
                        'signature_algorithm': cert.get('signatureAlgorithm'),
                        'san': cert.get('subjectAltName', [])
                    }
        except Exception as e:
            return {'error': str(e)}
    
    def verify_certificate_chain(self, hostname, port=443):
        """验证证书链"""
        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    # 如果连接成功，证书链验证通过
                    return True
        except ssl.SSLError as e:
            print(f"Certificate verification failed: {e}")
            return False
        except Exception as e:
            print(f"Connection failed: {e}")
            return False

class TLSServer:
    def __init__(self, cert_file, key_file):
        self.cert_file = cert_file
        self.key_file = key_file
        self.context = self._create_context()
    
    def _create_context(self):
        """创建SSL上下文"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.load_cert_chain(self.cert_file, self.key_file)
        
        # 设置安全选项
        context.options |= ssl.OP_NO_SSLv2
        context.options |= ssl.OP_NO_SSLv3
        context.options |= ssl.OP_NO_TLSv1
        context.options |= ssl.OP_NO_TLSv1_1
        
        # 设置密码套件
        context.set_ciphers('ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS')
        
        return context
    
    def start_server(self, host='localhost', port=8443):
        """启动TLS服务器"""
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:
            sock.bind((host, port))
            sock.listen(5)
            
            with self.context.wrap_socket(sock, server_side=True) as ssock:
                print(f"TLS Server listening on {host}:{port}")
                
                while True:
                    try:
                        conn, addr = ssock.accept()
                        print(f"Connection from {addr}")
                        
                        # 处理连接
                        self.handle_client(conn)
                        
                    except Exception as e:
                        print(f"Error handling client: {e}")
    
    def handle_client(self, conn):
        """处理客户端连接"""
        try:
            data = conn.recv(1024)
            if data:
                response = b"HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello, World!"
                conn.send(response)
        finally:
            conn.close()
```

## 身份认证和授权

### JWT 实现

```python
import jwt
import datetime
from functools import wraps

class JWTAuth:
    def __init__(self, secret_key, algorithm='HS256'):
        self.secret_key = secret_key
        self.algorithm = algorithm
    
    def generate_token(self, payload, expires_in=3600):
        """生成JWT令牌"""
        # 添加过期时间
        payload['exp'] = datetime.datetime.utcnow() + datetime.timedelta(seconds=expires_in)
        payload['iat'] = datetime.datetime.utcnow()
        
        token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        return token
    
    def verify_token(self, token):
        """验证JWT令牌"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise Exception("Token has expired")
        except jwt.InvalidTokenError:
            raise Exception("Invalid token")
    
    def refresh_token(self, token, expires_in=3600):
        """刷新令牌"""
        try:
            # 验证当前令牌（忽略过期）
            payload = jwt.decode(
                token, 
                self.secret_key, 
                algorithms=[self.algorithm],
                options={"verify_exp": False}
            )
            
            # 移除旧的时间戳
            payload.pop('exp', None)
            payload.pop('iat', None)
            
            # 生成新令牌
            return self.generate_token(payload, expires_in)
            
        except jwt.InvalidTokenError:
            raise Exception("Invalid token for refresh")
    
    def token_required(self, f):
        """装饰器：要求有效令牌"""
        @wraps(f)
        def decorated(*args, **kwargs):
            token = None
            
            # 从请求头获取令牌
            if 'Authorization' in request.headers:
                auth_header = request.headers['Authorization']
                try:
                    token = auth_header.split(" ")[1]  # Bearer <token>
                except IndexError:
                    return {'message': 'Invalid token format'}, 401
            
            if not token:
                return {'message': 'Token is missing'}, 401
            
            try:
                payload = self.verify_token(token)
                current_user = payload
            except Exception as e:
                return {'message': str(e)}, 401
            
            return f(current_user, *args, **kwargs)
        
        return decorated

# OAuth 2.0 实现示例
class OAuth2Server:
    def __init__(self):
        self.clients = {}
        self.authorization_codes = {}
        self.access_tokens = {}
        self.refresh_tokens = {}
    
    def register_client(self, client_id, client_secret, redirect_uris):
        """注册OAuth客户端"""
        self.clients[client_id] = {
            'client_secret': client_secret,
            'redirect_uris': redirect_uris
        }
    
    def generate_authorization_code(self, client_id, user_id, scope):
        """生成授权码"""
        import secrets
        
        code = secrets.token_urlsafe(32)
        self.authorization_codes[code] = {
            'client_id': client_id,
            'user_id': user_id,
            'scope': scope,
            'expires_at': datetime.datetime.utcnow() + datetime.timedelta(minutes=10)
        }
        
        return code
    
    def exchange_code_for_token(self, code, client_id, client_secret):
        """用授权码换取访问令牌"""
        # 验证授权码
        if code not in self.authorization_codes:
            raise Exception("Invalid authorization code")
        
        code_data = self.authorization_codes[code]
        
        # 检查过期时间
        if datetime.datetime.utcnow() > code_data['expires_at']:
            del self.authorization_codes[code]
            raise Exception("Authorization code expired")
        
        # 验证客户端
        if code_data['client_id'] != client_id:
            raise Exception("Client ID mismatch")
        
        if self.clients[client_id]['client_secret'] != client_secret:
            raise Exception("Invalid client secret")
        
        # 生成访问令牌和刷新令牌
        import secrets
        
        access_token = secrets.token_urlsafe(32)
        refresh_token = secrets.token_urlsafe(32)
        
        self.access_tokens[access_token] = {
            'user_id': code_data['user_id'],
            'client_id': client_id,
            'scope': code_data['scope'],
            'expires_at': datetime.datetime.utcnow() + datetime.timedelta(hours=1)
        }
        
        self.refresh_tokens[refresh_token] = {
            'user_id': code_data['user_id'],
            'client_id': client_id,
            'scope': code_data['scope']
        }
        
        # 删除已使用的授权码
        del self.authorization_codes[code]
        
        return {
            'access_token': access_token,
            'refresh_token': refresh_token,
            'token_type': 'Bearer',
            'expires_in': 3600
        }
    
    def verify_access_token(self, access_token):
        """验证访问令牌"""
        if access_token not in self.access_tokens:
            raise Exception("Invalid access token")
        
        token_data = self.access_tokens[access_token]
        
        if datetime.datetime.utcnow() > token_data['expires_at']:
            del self.access_tokens[access_token]
            raise Exception("Access token expired")
        
        return token_data
```

## 安全漏洞防护

### SQL 注入防护

```python
import sqlite3
from contextlib import contextmanager

class SecureDatabase:
    def __init__(self, db_path):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """初始化数据库"""
        with self.get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY,
                    username TEXT UNIQUE NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
    
    @contextmanager
    def get_connection(self):
        """安全的数据库连接管理"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def create_user(self, username, email, password_hash):
        """安全的用户创建（使用参数化查询）"""
        with self.get_connection() as conn:
            try:
                conn.execute(
                    "INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)",
                    (username, email, password_hash)
                )
                return True
            except sqlite3.IntegrityError:
                return False
    
    def get_user_by_username(self, username):
        """安全的用户查询"""
        with self.get_connection() as conn:
            cursor = conn.execute(
                "SELECT * FROM users WHERE username = ?",
                (username,)
            )
            return cursor.fetchone()
    
    def update_user_email(self, user_id, new_email):
        """安全的用户更新"""
        with self.get_connection() as conn:
            conn.execute(
                "UPDATE users SET email = ? WHERE id = ?",
                (new_email, user_id)
            )
    
    def search_users(self, search_term):
        """安全的用户搜索（防止SQL注入）"""
        # 使用LIKE查询时也要参数化
        with self.get_connection() as conn:
            cursor = conn.execute(
                "SELECT username, email FROM users WHERE username LIKE ? OR email LIKE ?",
                (f"%{search_term}%", f"%{search_term}%")
            )
            return cursor.fetchall()

# XSS 防护
import html
import re
from urllib.parse import quote

class XSSProtection:
    def __init__(self):
        # 危险的HTML标签
        self.dangerous_tags = [
            'script', 'iframe', 'object', 'embed', 'form',
            'input', 'textarea', 'button', 'select', 'option'
        ]
        
        # 危险的属性
        self.dangerous_attrs = [
            'onload', 'onclick', 'onmouseover', 'onerror',
            'onsubmit', 'onchange', 'onkeyup', 'onkeydown'
        ]
    
    def escape_html(self, text):
        """HTML转义"""
        return html.escape(text, quote=True)
    
    def sanitize_html(self, html_content):
        """HTML净化"""
        # 移除危险标签
        for tag in self.dangerous_tags:
            pattern = re.compile(f'<{tag}[^>]*>.*?</{tag}>', re.IGNORECASE | re.DOTALL)
            html_content = pattern.sub('', html_content)
            
            # 移除自闭合标签
            pattern = re.compile(f'<{tag}[^>]*/?>', re.IGNORECASE)
            html_content = pattern.sub('', html_content)
        
        # 移除危险属性
        for attr in self.dangerous_attrs:
            pattern = re.compile(f'{attr}\\s*=\\s*["\'][^"\']*["\']', re.IGNORECASE)
            html_content = pattern.sub('', html_content)
        
        # 移除javascript:协议
        pattern = re.compile(r'javascript:', re.IGNORECASE)
        html_content = pattern.sub('', html_content)
        
        return html_content
    
    def validate_url(self, url):
        """URL验证"""
        # 检查协议
        allowed_protocols = ['http', 'https', 'ftp']
        
        if '://' in url:
            protocol = url.split('://')[0].lower()
            if protocol not in allowed_protocols:
                return False
        
        # 检查危险字符
        dangerous_chars = ['<', '>', '"', "'", '&']
        for char in dangerous_chars:
            if char in url:
                return False
        
        return True
    
    def safe_redirect(self, url, allowed_domains=None):
        """安全重定向"""
        if not self.validate_url(url):
            return None
        
        if allowed_domains:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            if parsed.netloc and parsed.netloc not in allowed_domains:
                return None
        
        return url

# CSRF 防护
import secrets
import hmac
import hashlib

class CSRFProtection:
    def __init__(self, secret_key):
        self.secret_key = secret_key
    
    def generate_token(self, session_id):
        """生成CSRF令牌"""
        timestamp = str(int(datetime.datetime.utcnow().timestamp()))
        message = f"{session_id}:{timestamp}"
        
        signature = hmac.new(
            self.secret_key.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        
        token = f"{timestamp}:{signature}"
        return token
    
    def verify_token(self, token, session_id, max_age=3600):
        """验证CSRF令牌"""
        try:
            timestamp_str, signature = token.split(':', 1)
            timestamp = int(timestamp_str)
            
            # 检查时间戳
            current_time = int(datetime.datetime.utcnow().timestamp())
            if current_time - timestamp > max_age:
                return False
            
            # 验证签名
            message = f"{session_id}:{timestamp_str}"
            expected_signature = hmac.new(
                self.secret_key.encode(),
                message.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
            
        except (ValueError, TypeError):
            return False
```

## 总结

网络安全基础的核心要点：

1. **加密技术** - 对称加密、非对称加密的原理和应用
2. **哈希和签名** - 数据完整性验证和身份认证
3. **网络协议** - TLS/SSL 安全通信协议
4. **身份认证** - JWT、OAuth 2.0 等认证机制
5. **漏洞防护** - SQL注入、XSS、CSRF 等常见攻击的防护
6. **安全实践** - 密码策略、访问控制、日志审计

掌握这些基础知识将帮助你构建更安全的应用系统。